import re

from addict import Dict

SEVERITIES = ["LOW", "MODERATE", "HIGH", "CRITICAL"]


def get_max_severity(repo):
    max_severity_index = -1
    severity = "NONE"

    for va_edge in repo.vulnerabilityAlerts.edges:

        for v_edge in va_edge.node.securityAdvisory.vulnerabilities.edges:

            edge_severity = v_edge.node.severity
            severity_index = SEVERITIES.index(edge_severity)
            if severity_index > max_severity_index:
                max_severity_index = severity_index
                severity = edge_severity

    return severity


def group_by_severity(repositories):
    vulnerable_by_severity = Dict({sev: [] for sev in SEVERITIES})
    for repo in repositories:
        severity = get_max_severity(repo)
        vulnerable_by_severity[severity].append(repo)
    return vulnerable_by_severity


def get_uniform_version(version):
    components = re.findall(r"\d+", version)
    uniform = ".".join(components)
    return uniform


def get_sortable_version(version):
    version_components = re.findall(r"\d+", version)
    print(version_components)
    sortable = []
    for component in version_components:
        sortable.append(format(int(component), "04d"))

    return ".".join(sortable)


def get_patch_list(repo):
    """
    The same package can have multiple alerts or multiple advisories within the same
    alert so to get down to one recommended version per package you have to do an
    aggregation for the advisories in each alert and then to see if there are
    multiple alerts for the same package.

    Also the highest patched version may not correspond to the highest severity
    of all the advisories.
    """
    repo_patches = {}
    for v_edge in repo.vulnerabilityAlerts.edges:
        package = v_edge.node.packageName
        print(package)
        dependency_file = v_edge.node.vulnerableManifestPath
        required_version = get_uniform_version(v_edge.node.vulnerableRequirements)
        sortable_version = get_sortable_version(required_version)
        print(f"{required_version} == {sortable_version}")

        patch_sortable_version = None
        patch_version = None
        patchable = False
        max_severity = 0
        advisories = v_edge.node.securityAdvisory.vulnerabilities.edges
        for a_edge in advisories:
            advisory = a_edge.node
            severity_index = SEVERITIES.index(advisory.severity)
            if severity_index > max_severity:
                max_severity = severity_index

            if advisory.firstPatchedVersion:
                patchable = True
                advisory_patch_version = get_uniform_version(
                    advisory.firstPatchedVersion.identifier
                )
                advisory_sortable_version = get_sortable_version(advisory_patch_version)

                if (not patch_version) or (
                    advisory_sortable_version > patch_sortable_version
                ):
                    patch_version = advisory_patch_version
                    patch_sortable_version = advisory_sortable_version

        first = package not in repo_patches
        later = False

        if package in repo_patches:
            later = patch_sortable_version and (
                repo_patches[package]["sortable_version"] < patch_sortable_version
            )
            if repo_patches[package]["severity_index"] > max_severity:
                max_severity = repo_patches[package]["severity_index"]

        newer = first or later

        if newer:
            repo_patches[package] = {
                "package": package,
                "dependency_file": dependency_file,
                "current_version": required_version,
                "patch_available": patchable,
                "patch_version": patch_version,
                "sortable_version": patch_sortable_version,
                "severity": SEVERITIES[max_severity],
                "severity_index": max_severity,
            }
            print(
                f"For {repo.name} patch {package} from {required_version} to {patch_version}"
            )

    # sort by descending severity
    if len(repo_patches.keys()) > 0:
        patch_list = [patch for package, patch in repo_patches.items()]
        patch_list.sort(key=lambda patch: patch["severity_index"], reverse=True)
        print(patch_list)
        patches = {patch["package"]: patch for patch in patch_list}
    else:
        patches = {}

    return patches
